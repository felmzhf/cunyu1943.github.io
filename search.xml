<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java知识点总结-3</title>
      <link href="/2019/10/02/java-zhi-shi-dian-zong-jie-3/"/>
      <url>/2019/10/02/java-zhi-shi-dian-zong-jie-3/</url>
      
        <content type="html"><![CDATA[<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><ul><li>使用规则<ul><li>abstract定义抽象类；</li><li>abstract定义抽象方法，只有声明，不需要实现；</li><li>包含抽象方法的类是抽象类；</li><li>抽象类中可以包含普通方法，也可以没有抽象方法；</li><li>抽象类不能直接创建，可以定义引用变量；</li></ul></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>定义：一种特殊的类，由全局常量和公共的抽象方法所组成；</li><li>类是一种具体实现体，而接口定义了某一批类所要遵守的规范，接口不关心这些类的内部数据，也不关心这些类中方法的实现细节，它只规定这些类中必须提供某些方法；</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-43670d671624dbfc?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"> </p><ul><li>接口使用：一个类可以实现一个或多个接口，实现接口使用implements关键字。Java中一个类只能继承一个父类，可以通过多个接口做补充；</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-984df175a489393a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><ul><li>定义：统一建模语言或标准建模语言，是一个支持模型化和软件系统开发的图形化语言，为软件开发的所有阶段提供模型化和可视化支持；</li></ul><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><ul><li>处理运行时异常时，采用逻辑去合理规避同时辅助try-catch处理；</li><li>在多重catch块后面，可以加一个catch(Exception)来处理可能被遗漏的异常；</li><li>对于不确定的代码，也可以加上try-catc，处理潜在的异常；</li><li>尽量去处理异常，切忌只是简单的调用printStackTrace()去打印输出；</li><li>具体如何处理异常，要根据不用的业务需求和异常类型去决定；</li><li>尽量天剑finally语句块去释放占用的资源；</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ul><li>String对象创建后不能被修改，是不可变的，所谓的修改其实是创建了新的对象，所指向的内存空间不同；</li><li>每次new一个字符串就是产生了一个新对象，即便两个字符串的内容相同，使用”==”比较时也为<code>false</code>，若只需比较内容是否相同，应使用<code>eauals()</code>方法；</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-e286923822e8edd4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="String类常用方法"></p><ul><li><code>==</code>和<code>equals()</code>的区别<ul><li><code>==</code>判断两个字符串在内存中首地址是否相同，即判断是否同一个字符串对象；</li><li><code>equals</code>：比较存储在两个字符串对象中的内容是否一致；</li></ul></li><li>StringBuffer是线程安全的，而StringBuilder则没有实现线程安全功能，所以性能更高；</li></ul><h2 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h2><ul><li>基本类型和包装类之间的对应关系：</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-638245ec883cc52c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li><p>包装类提供的两大类</p><ul><li>将本类型和其他基本类型进行转换的方法；</li><li>将字符串和本类型及包装类互相装换的方法；</li></ul></li><li><p>装箱：把基本类型转换成包装类，使其具有对象的性质，又可分为手动装箱和自动装箱；</p></li><li><p>拆箱：把包装类对象转换程基本类型的值，分为手动拆箱和自动拆箱；</p></li><li><p>基本类型转换为字符串的三种方法：</p><ul><li>使用包装类的<code>toString()</code>方法；</li><li>使用String类的<code>valueof()</code>方法；</li><li>用一个空字符串加上基本类型，得到的就是基本数据类型对应的字符串；</li></ul></li><li><p>将字符串转换为基本类型的两种方法：</p><ul><li>调用包装类的<code>parseXxx</code>静态方法；</li><li>调用包装类的<code>valueOf()</code>方法转换为基本类型的包装类，会自动拆箱；</li></ul></li></ul><h2 id="时间"><a href="#时间" class="headerlink" title="时间"></a>时间</h2><ul><li>调用<code>SimpleDateFormat</code>对象的<code>parse()</code>方法时可能会出现转换异常，即ParseException，因此需要进行异常处理；</li><li>使用Date类时需要导入<code>java.util</code>包，使用<code>SimpleDateFormat</code>时需要导入<code>java.text</code>包；</li><li>调用<code>Calendar</code>获取月份时，月份是从<code>0</code>开始的；</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-7d6cc94dfde0f360?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><blockquote><p>###Math类</p></blockquote><ul><li><code>Math</code>位于<code>java.lang</code>包中，包含用于执行基本数学运算的方法，类中所有方法懂事静态方法，可以直接使用<code>类名.方法名()</code>；</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-c5f27295fd8a698b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><ul><li>定义：一种工具类，就像是容器，储存任意数量的具有共同属性的对象；</li><li>作用<ul><li>在类的内部，对数据进行组织；</li><li>简单而快速的搜索大数量的条目；</li><li>有的集合接口，提供一系列排列有序的元素，且可以在序列中间快速插入或者删除有关元素； </li><li>有的集合接口，提供映射关系，可以通过关键字(key)去快速查找到对应的唯一对象，而这个关键字可以是任意类型；</li></ul></li><li>数组与集合区别<ul><li>数组长度固定，集合长度可变；</li><li>数组只能通过下标访问元素，类型固定，而有的集合可以通过任意类型查找所映射的具体对象；</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-aaa99fdeb8c71cc9?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>Collection接口<ul><li>是List、Set、Queue接口的父接口；</li><li>定义了可用于操作List、Set、Queue的方法–增删改查；</li></ul></li><li>List接口及其实现类–ArrayList<ul><li>List是元素有序且可重复的集合，被称为序列；</li><li>List可以精确控制每个元素的插入位置，或删除某个位置元素；</li><li>ArrayList–数组序列，是List的一个重要实现类；</li><li>ArrayList底层由数组实现；</li></ul></li><li>Map接口<ul><li>Map提供了一种映射关系，其中的元素是以键值对<code>(key-value)</code>的形式存储的，能够实现根据key快速查找value；</li><li>Map中的键值对以Entry类型的对象实例形式存在；</li><li>键(key)不可以重复，value可以；</li><li>每个键最多只能映射到一个值；</li><li>Map接口提供了分别返回key值集合、value值集合以及Entry(键值对)集合的方法；</li><li>Map支持泛型，形如：Map&lt;K,V&gt;；</li></ul></li><li>HashMap类<ul><li>HashMap是Map的一个重要实现类，也是最常用的，基于哈希表实现；</li><li>HashMap中的Entry对象时无序排列的；</li><li>Key值和value值都可以为null，但是一个HashMap只能有一个key值为null的映射(key值不可重复)；</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java知识点总结-2</title>
      <link href="/2019/10/02/java-zhi-shi-dian-zong-jie-2/"/>
      <url>/2019/10/02/java-zhi-shi-dian-zong-jie-2/</url>
      
        <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h4 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h4><ul><li>声明<ul><li><code>数据类型[] 数组名；</code></li><li><code>数据类型 数组名[]；</code></li></ul></li><li>分配空间<ul><li><code>数组名 = new 数据类型 [数组长度]；</code></li></ul></li><li>可以在声明的同时分配空间，分配空间之后数组中才能放数据，数组元素都是通过下标来访问，声明数组的同时赋值时不能指定数组长度；</li><li>foreach：<code>for(元素类型 元素变量：遍历对象){ 执行的代码；}；</code></li></ul><h4 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h4><ul><li>声明并分配空间：<code>数据类型[][]  数组名 = new 数据类型 [行的个数][列的个数]；</code><br><img src="http://upload-images.jianshu.io/upload_images/9747350-e39f276df7b6fa68?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></li><li>在定义二维数组时可以只指定行的个数，然后再为每一行分别指定列的个数，若每行列数不同，则创建的是不规则的二维数组；</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li><p>定义语法：<code>访问修饰符 返回值类型 方法名(参数列表){  方法体；}；</code></p></li><li><p>分类：</p><ul><li>无参无返回值方法；</li><li>无参带返回值方法；</li><li>带参无返回值方法；</li><li>带参带返回值方法；<ul><li>调用方法：<code>对象名.方法名()</code></li><li>调用带参方法时，必须保证实参的数量，类型，顺序和形参一一对应；</li><li>调用方法时，实参不需要指定数据类型；</li><li>方法的参数既可以是基本数据类型，也可以是引用数据类型，当有多个参数时，多个参数间以逗号分割；</li><li>重载：在同一个类中，方法名相同，方法参数个数、顺序或类型不同称为方法的重载，与方法的修饰符或返回值无关系；</li></ul></li></ul></li></ul><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><ul><li>类是模子，确定对象将拥有的特征(属性)和行为(方法)，特点：类是对象的类型，具有相同属性和方法的一组对象的集合；</li><li>定义类的步骤：<ul><li>定义类名；</li><li>编写类的属性；</li><li>编写类的方法；</li></ul></li><li>使用对象的步骤：<ul><li>创建对象：<code>类名 对象名 = new 类名()；</code></li><li>使用对象：<code>引用对象的属性：对象名.属性；</code></li></ul></li></ul><h2 id="成员变量与局部变量"><a href="#成员变量与局部变量" class="headerlink" title="成员变量与局部变量"></a>成员变量与局部变量</h2><ul><li>成员变量：在类中定义，用来描述对象将要有什么，既可被本类的方法使用，还能供其他类的方法使用；</li><li>局部变量：在类的方法中定义，在方法中临时保存数据，只能在当前方法中使用；</li><li>区别：<ul><li>局部变量作用域仅限于定义它的方法，成员变量的作用域在整个类内部都是可见的；</li><li>成员变量有初始值，但局部变量未赋予初始值；</li><li>不同方法中可以有同名局部变量，同一方法中，不允许有同名局部变量；</li><li>两者重名时，局部变量优先级更高；</li></ul></li></ul><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><ul><li>使用new+构造方法，创建一个新对象；</li><li>构造方法是定义在Java类中的一个用来初始化对象的方法，构造方法与类同名且无返回值；</li><li>当无指定构造方法时，系统会自动添加无参的构造方法；</li><li>当有指定构造方法，无论是有参、无参的构造方法，都不会自动添加无参的构造方法；</li><li>构造方法的重载：方法名相同，但参数不同的多个方法，调用时会自动根据不同的参数选择相应方法；</li><li>构造方法不但可以给对象的属性赋值，还可以保证给对象的属性赋一个合理的值；</li></ul><h2 id="static"><a href="#static" class="headerlink" title="static"></a>static</h2><ul><li>static修饰的成员称为静态成员或类成员，属于整个类所有，而不是某个对象所有，即被类的所有对象所共享。静态成员可以使用类名直接访问，也可以使用对象名进行访问，static可以修饰变量、方法和代码块；</li><li>静态成员属于整个类，当系统第一次使用该类时，就会为其分配内存空间直到该类别卸载才会进行资源回收；</li><li>static修饰的方法称为静态方法或类方法，静态方法中可以直接调用同类中的静态成员，但不能直接调用非静态成员，如果想要在静态方法中调用非静态变量，可以通过创建类的对象，然后通过对象来访问非静态变量；</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HelloWorld</span><span class="token punctuation">{</span>    String name <span class="token operator">=</span> <span class="token string">"村雨"</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> String hobby <span class="token operator">=</span> <span class="token string">"basketball"</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"姓名"</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"爱好"</span> <span class="token operator">+</span> hobby<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://upload-images.jianshu.io/upload_images/9747350-dbc8da50a41f62dd?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>普通成员方法中，可以直接访问同类的非静态变量和静态变量；</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-6f990b75f477e757?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>静态方法中不能直接调用非静态方法，需要通过对象来访问非静态方法；</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-53423f3c52d8b389?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>静态初始化块只在类加载时执行，且只执行一次，同时静态初始化块只能给静态变量复制，不能初始化普通的成员变量；</li></ul><h2 id="面向对象特点"><a href="#面向对象特点" class="headerlink" title="面向对象特点"></a>面向对象特点</h2><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul><li>概念：将类的某些信息隐藏在类内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问；</li><li>好处：只能通过规定的方法访问数据，隐藏类的实例细节，方便修改和实现；</li><li>实现步骤：<ul><li>修改属性可见性，设为private；</li><li>创建getter/setter方法用于属性读写；</li><li>在getter/setter方法中加入属性控制语句，对属性值的合法性进行判断；</li></ul></li></ul><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li><p>Java中是单继承；</p></li><li><p>优点：</p><ul><li>子类拥有父类的所有属性和方法；</li><li>实现代码复用；</li></ul></li><li><p>重写：返回值类型，方法名，参数类型及个数都要与父类继承的方法相同，才叫方法的重写；</p></li><li><p>继承的初始化顺序</p><ul><li>初始化父类再初始化子类；</li><li>先执行初始化对象中属性，再执行构造方法中的初始化；</li></ul></li><li><p>final</p><ul><li>修饰类，则该类不允许被继承；</li><li>修饰方法，则该方法不允许被覆盖(重写)；</li><li>修饰属性：则该类属性不会进行隐式初始化(类的初始化属性必须有值)活在构造方法中赋值(但只能选其一)；</li><li>修饰变量，则该变量的值只能赋一次值，即变为常量；</li></ul></li><li><p>super</p><ul><li>子类构造过程中必须调用父类构造方法；</li><li>若子类构造方法中既没有显示调用父类构造方法，而父类有没有无参的构造方法，则编译出错；</li><li>若显式调用构造方法，必须在子类构造方法的第一行；</li><li>若子类构造方法中未显示调用父类的构造方法，则系统默认调用父类无参的构造方法；</li></ul></li><li><p>equals()方法：比较的是对象的引用是否指向同一块内存地址；</p></li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li>引用多态<ul><li>父类引用可以指向本类对象；</li><li>父类引用可以指向子类对象；</li></ul></li><li>方法多态<ul><li>创建本类对象时，调用的方法为本类方法；</li><li>创建子类对象时，调用的方法为子类重写的方法或者继承的方法；</li></ul></li><li>引用类型转换<ul><li>向上类型转换(隐式/自动类型转换)，是小类型到大类型的转换，无风险；</li><li>向下类型转换(强制类型转换)，是大类型到小类型，存在风险；</li><li>instanceof运算符，用来解决引用对象的类型，避免类型转换的安全性问题；</li></ul></li></ul><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><ul><li>作用：<ul><li>管理Java文件；</li><li>解决同名文件冲突；</li></ul></li><li>必须放在Java源程序的第一行，包名间可以使用<code>.</code>号隔开；</li><li>系统中的包<ul><li>java.(功能).(类)</li><li>java.lang.(类)  包含Java语言基础的类；</li><li>java.util.(类)  包含Java语言中各种工具类；</li><li>java.io.(类)  包含输入、输出相关功能的类；</li></ul></li></ul><h2 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h2><p><img src="http://upload-images.jianshu.io/upload_images/9747350-6950e2dd2ca27f1f?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ul><li>定义：定义在另一个类里面的类，与之对应，包含内部类的类被称为外部类；</li><li>作用<ul><li>提供更好的封装，可把内部类隐藏在外部类之内，不允许同一个包中的其他类访问该类；</li><li>内部类的方法可以直接访问外部类的所有数据，包括私有的数据；</li><li>内部类所实现的功能使用外部类同样可以实现，只是有时使用内部类更方便；</li></ul></li><li>分类<ul><li>成员内部类；</li><li>静态内部类；</li><li>方法内部类；</li><li>匿名内部类；</li></ul></li><li>调用方式</li></ul><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span><span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Test test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Demo demo <span class="token operator">=</span> test<span class="token punctuation">.</span><span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre><code>内部类 对象名 = 外部类对象.new 内部类();</code></pre><ul><li><p>内部类中方法可以直接访问外部类中的数据，而不受访问控制符的影响，但外部类是不能使用内部类的成员和方法；</p></li><li><p>若外部类和内部类具有相同的成员变量或方法，内部类默认访问自己的成员变量或方法，若要访问外部类的成员变量，可以使用this关键字；<br><img src="http://upload-images.jianshu.io/upload_images/9747350-42ecc9a1e6e191db?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p></li><li><p>静态内部类</p><ul><li>特点<ul><li>静态内部类不能直接访问外部的非静态成员，通过<code>new 外部类().成员</code>的方式访问；</li><li>若外部类的静态成员与内部类的成员名称相同，可通过“类名.静态成员”访问外部类的静态成员；若外部类的静态成员与内部类的成员名称不同，则可通过”成员名”直接调用外部类的静态成员；</li><li>创建静态内部类的对象时，不需要内部类的对象，可直接创建<code>内部类 对象名 = new 内部类();</code></li></ul></li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-9bf85bc6ad25fa9a?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>方法内部类：内部类定义在外部类的方法中，方法内部类只在该方法的内部可见，即只能在该方法中使用，由于方法内部类不能在外部类的方法以外的地方使用，因此方法内部类不能使用访问控制服和static修饰符；</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-d41a0bb96f73f7e7?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java知识点总结-1</title>
      <link href="/2019/10/02/java-zhi-shi-dian-zong-jie-1/"/>
      <url>/2019/10/02/java-zhi-shi-dian-zong-jie-1/</url>
      
        <content type="html"><![CDATA[<ul><li>JVM(Java Virtual Machine)：源文件-&gt;编译器-&gt;字节码文件-&gt;解释器-&gt;程序；</li><li>JDK:Java Development Kit，Java开发工具包；</li><li>JRE:Java Runtime Environment，Java运行时环境；</li><li>Java是一种强类型语言，即它所存储的数据都是有类型的，且必须在编译时就确定其类型；<h3 id="数据类型："><a href="#数据类型：" class="headerlink" title="数据类型："></a>数据类型：</h3><ul><li>基本数据类型;</li><li>数值型：<ul><li>整数类型：byte，short，int，long；</li><li>浮点型：float，double；</li></ul></li><li>字符型：char；</li><li>布尔型：boolean；</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-6af0245f95206ead?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>引用数据类型：<ul><li>类；</li><li>接口；</li><li>数组；</li></ul></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-f9f6f2216f98a90c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="变量使用规则："><a href="#变量使用规则：" class="headerlink" title="变量使用规则："></a>变量使用规则：</h3><ul><li>先声明再使用；</li><li>可以在声明的同时进行初始化；</li><li>变量中每次只能赋一个值，但可以修改多次；</li><li>变量名使用中文无语法错误，但不建议使用；</li></ul><h3 id="自动类型转换需满足的条件"><a href="#自动类型转换需满足的条件" class="headerlink" title="自动类型转换需满足的条件"></a>自动类型转换需满足的条件</h3><ul><li>目标类型能与源类型兼容；</li><li>目标类型大于源类型；</li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><ul><li>设定后在程序运行过程中不允许改变；</li><li>语法：final 数据类型 变量名 = 值；</li></ul><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ul><li>单行注释：//</li><li>多行注释：/*     */</li><li>文档注释：/**   */</li></ul><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><ul><li>算数运算符；</li><li>赋值运算符；</li><li>比较运算符；</li><li>逻辑运算符；</li><li>条件运算符：语法形式：布尔表达式？表达式1：表达式2；</li></ul><h3 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h3><p><img src="http://upload-images.jianshu.io/upload_images/9747350-9ae019ea388631e1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="if…else"><a href="#if…else" class="headerlink" title="if…else"></a>if…else</h3><ul><li>单重if</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-63faddddd4116d84?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>多重if</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-a6857f15c433a075?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><ul><li>嵌套if</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-a337d8b762278c0c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h3 id="条件之switch"><a href="#条件之switch" class="headerlink" title="条件之switch"></a>条件之switch</h3><ul><li>switch后小括号中表达式的值必须是整形或字符型；</li><li>case后的值可以是常量数值，也可以是常量表达式；</li><li>case匹配后，执行匹配快中程序代码，若未遇到break会继续执行下一个的case块的内容，直到遇到break或switch语句块结束；</li></ul><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li>while：特点是先判断，后执行；</li><li>do…while：特点是先执行，后判断，保证循环至少被执行一次；</li><li>for：语法：for(循环变量初始化；循环条件；循环变量变化){<br> 循环条件；<br>}</li><li>do…while循环结束的条件是while后的条件成立；</li><li>break：作用是终止整个循环体的执行；</li><li>continue：跳过循环体中剩余的语句并进行下一次循环；</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式</title>
      <link href="/2019/10/02/java-she-ji-mo-shi/"/>
      <url>/2019/10/02/java-she-ji-mo-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式基础"><a href="#设计模式基础" class="headerlink" title="设计模式基础"></a>设计模式基础</h2><ul><li><h4 id="设计模式主要基于的面向对象设计的原则："><a href="#设计模式主要基于的面向对象设计的原则：" class="headerlink" title="设计模式主要基于的面向对象设计的原则："></a>设计模式主要基于的面向对象设计的原则：</h4><ul><li>程序到一个接口不用实现</li><li>有利于对继承对象组合；</li></ul></li><li><h4 id="设计模式用途："><a href="#设计模式用途：" class="headerlink" title="设计模式用途："></a>设计模式用途：</h4><ul><li>开发人员的通用平台；</li><li>最佳实践；<ul><li><h4 id="类型："><a href="#类型：" class="headerlink" title="类型："></a>类型：</h4></li></ul></li><li>创造模式：提供了一种创建对象而隐藏创建逻辑的方法，而非直接使用<code>new</code>来实例化对象；</li><li>结构模式：涉及类和对象组成，继承概念用于组成接口并定义方法组合对象以获得新功能；</li><li>行为模式：侧重于对象之间的通信；</li><li>J2EE模式：设计表示层，由<code>Sun Java Center</code>标识；</li></ul></li></ul><h2 id="创造设计模式"><a href="#创造设计模式" class="headerlink" title="创造设计模式"></a>创造设计模式</h2><ul><li><h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><ul><li>无创建逻辑暴露给客户端创建对象，使用一个通用接口引用新创建的对象；<ul><li>实现步骤：<ul><li>创建一个接口；</li><li>创建实现相同接口的具体类；</li><li>创建工厂根据给定信息生成具体类的对象；</li><li>使用工厂通过传递类型等信息来获取具体类的对象；</li><li>验证结果；</li></ul></li></ul></li></ul></li></ul><ul><li><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><ul><li>接口负责创建相关对象的工厂，而不明确指定他们的类，每个生成的工厂可按照工厂模式提供对象；</li></ul></li><li><h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><ul><li>设计一个类，负责创建一个对象，同时确保只创建一个对象，类提供一种方法来访问它的唯一对象，可直接访问而不需要实例化类对象；</li></ul></li><li><h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><ul><li>涉及实现一个原型接口，只创建当前对象的克隆；</li></ul></li><li><h4 id="Builder模式"><a href="#Builder模式" class="headerlink" title="Builder模式"></a><code>Builder</code>模式</h4><ul><li>构造器逐步构建最终对象，此构造器独立于其他对象；</li></ul></li></ul><h2 id="结构设计模式"><a href="#结构设计模式" class="headerlink" title="结构设计模式"></a>结构设计模式</h2><ul><li><h4 id="适配器-Adapter-模式"><a href="#适配器-Adapter-模式" class="headerlink" title="适配器(Adapter)模式"></a>适配器(<code>Adapter</code>)模式</h4><ul><li>组合两个相互独立不兼容接口之间的桥梁，涉及一个单独的类，负责连接独立或不兼容接口的功能；</li></ul></li><li><h4 id="桥接-Bridge-模式"><a href="#桥接-Bridge-模式" class="headerlink" title="桥接(````Bridge```)模式"></a>桥接(````Bridge```)模式</h4><ul><li>定义与实现分离，涉及一个充当桥接的接口，这样使得具体类与接口实现者类无关；</li></ul></li><li><h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><ul><li>以同样的方式处理一组对象作为单个对象，根据树结构组成对象，以表示部分以及整个层次结构；</li></ul></li><li><h4 id="过滤器-条件-模式"><a href="#过滤器-条件-模式" class="headerlink" title="过滤器(条件)模式"></a>过滤器(条件)模式</h4><ul><li>使开发人员可以使用不同条件过滤一组对象，并通过逻辑操作以解耦方式将其链接；</li></ul></li><li><h4 id="装饰者-Decorator-模式"><a href="#装饰者-Decorator-模式" class="headerlink" title="装饰者(Decorator)模式"></a>装饰者(<code>Decorator</code>)模式</h4><ul><li>允许用户向现有对象添加新功能而不改变其结构，创建一个修饰器类用于包装原始类并提供附加功能，保持类方法签名完整；</li></ul></li><li><h4 id="外观-Facade-模式"><a href="#外观-Facade-模式" class="headerlink" title="外观(Facade)模式"></a>外观(<code>Facade</code>)模式</h4><ul><li>隐藏系统复杂性，并为客户端提供一个可以访问系统的接口，提供客户端所需的简化方法和委托调用现有系统类的方法；</li></ul></li><li><h4 id="享元-Flyweight-模式"><a href="#享元-Flyweight-模式" class="headerlink" title="享元(Flyweight)模式"></a>享元(<code>Flyweight</code>)模式</h4><ul><li>主要用于减少创建的对象数量，减少内存占用并提高性能，此模式尝试通过存储已存在的类似对象以重用，并在找不到所匹配的对象时创建新对象；</li></ul></li><li><h4 id="业务代理模式"><a href="#业务代理模式" class="headerlink" title="业务代理模式"></a>业务代理模式</h4><ul><li>常用于解耦表示层和业务层，用于减少层代码中的业务层代码的通信或远程查找功能，业务层中实体如下：<ul><li>客户端：表示层代码可以是<code>JSP</code>，<code>servlet</code>或<code>UI java</code>代码；</li><li>业务代理：为客户端实体提供对业务服务方法的访问的单入口点类；</li><li>查找服务：负责获得相关业务的实施和提供业务的委托对象业务对性爱难过的访问；</li><li>业务服务：具体类实现这个业务服务以提供实际的业务实现逻辑；</li></ul></li></ul></li></ul><h2 id="行为设计模式"><a href="#行为设计模式" class="headerlink" title="行为设计模式"></a>行为设计模式</h2><ul><li><h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><ul><li>为请求创建一系列接收者对象，将发送方与接收方分离，每个接收器中都包含着对另一个接收器的引用，若有一个对象不能处理请求，则将相同对象传递给下一个接收者；</li></ul></li><li><h4 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h4><ul><li>数据驱动设计模式，请求作为命令包装在一个对象下，并传递给调用器对象，调用者对象查找可以处理此命令的适当对象，并将命令传递到执行命令的相应对象；</li></ul></li><li><h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><ul><li>提供了一种评估计算语法或表达式的方法，设计实现一个表达式接口，用于解释一个指定的上下文，常用于SQL解析，符号处理引擎等；</li></ul></li><li><h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><ul><li>用于以顺序方式访问集合对象的元素，且不需知道其底层表示；</li></ul></li><li><h4 id="调解者-Mediator-模式"><a href="#调解者-Mediator-模式" class="headerlink" title="调解者(Mediator)模式"></a>调解者(<code>Mediator</code>)模式</h4><ul><li>用于减少多个对象或类之间的通信复杂性，提供一个中介类，用于处理不同类之间的所有通信，并支持通过松散耦合来维护代码；</li></ul></li><li><h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><ul><li>用于恢复一个对象以前的状态；</li></ul></li><li><h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><ul><li>在对象之间存在一对多关系时使用；</li></ul></li><li><h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><ul><li>类根据其状态改变而变，在这个模式中，我们创建表示各种状态的对象，以及随对象状态变化而行为变化的上下文对象；     </li></ul></li><li><h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><ul><li>此模式中，可在运行时更改类行为或其算法，创建表示各种策略对象和其行为根据其策略对象而变化的上下文对象；</li></ul></li><li><h4 id="模版模式"><a href="#模版模式" class="headerlink" title="模版模式"></a>模版模式</h4><ul><li>抽象类中公开了定义的方法/模版来执行它的方法，其子类可以根据需要重写方法实现，但调用方式与抽象类定义的方式相同；</li></ul></li><li><h4 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h4><ul><li>使用访问者类来改变元素类的执行算法，通过此方式，元素执行算法可随访问者变化而变化，根据每个模式，元素对象必须接受访问者对象，以便访问者对象处理对元素对元素对象的操作；</li></ul></li><li><h4 id="空对象模式"><a href="#空对象模式" class="headerlink" title="空对象模式"></a>空对象模式</h4><ul><li>在这个模式中，空对象将替换<code>NULL</code>对象实例的检查，而非检查一个空值，<code>NULL</code>对象反映一个无关的关系，还可以用于在数据不可用时提供默认行为，空对象模式创建一个抽象类，指定要执行的各种操作，扩展此类的具体类和一个<code>NULL</code>对象类，不提供此类的任何实现，且无需检查空值；</li></ul></li><li><h4 id="MVC模式"><a href="#MVC模式" class="headerlink" title="MVC模式"></a>MVC模式</h4><ul><li>模型：表示携带数据对象或<code>JAVA POJO</code>，若其数据改变也可以具有逻辑来更新控制器；</li><li>视图：表示模型包含的数据的可视化层；</li><li>控制器：对模型和视图都起作用，控制数据流进入模型对象，并在数据更改时更新视图，保持视图与模型分开，也就是处于视图与模型的中间层；</li></ul></li><li><h4 id="组合实体模式"><a href="#组合实体模式" class="headerlink" title="组合实体模式"></a>组合实体模式</h4><ul><li>用于<code>EJB</code>持久化机制，表示对象图的<code>EJB</code>实体<code>bean</code>，组合实体更新时，内部依赖对象<code>bean</code>将自动更新为有EJB实体bean管理，<code>Bean</code>参与者为：<ul><li>组合实体：主要的实体<code>bean</code>，可以是粗粒度的或可以包含用于持久性目的的粗粒度对象；</li><li>粗粒实体：包含依赖对象，有自己的生命周期；</li><li>依赖对象：是一个对象，取决于其持久度生命周期粗粒对象；</li><li>策略：表示如何实现复组合实体；</li></ul></li></ul></li><li><h4 id="数据访问对象模式"><a href="#数据访问对象模式" class="headerlink" title="数据访问对象模式"></a>数据访问对象模式</h4><ul><li>用于将低级数据访问<code>API</code>或操作与高级业务服务分离，模式的参与者为：<ul><li>数据访问对象接口：定义要对模型对象执行的标准操作；</li><li>数据访问对象具体类：负责从数据源获取数据，数据源可以是数据库/<code>xml</code>或任何其他存储机制；</li><li>模型对象或值对象：简单的<code>POJO</code>，包含用于存储使用<code>DAO</code>类检索的<code>get/set</code>方法；</li></ul></li></ul></li><li><h4 id="前端控制器模式"><a href="#前端控制器模式" class="headerlink" title="前端控制器模式"></a>前端控制器模式</h4><ul><li>用于提供集中式请求处理机制，以便所有请求由单个处理程序处理，可以执行请求的身份验证、授权、记录或跟踪，然后将请求传递到相应处理程序，包含的实体为：<ul><li>前端控制器：用于处理应用程序(基于Web或桌面)的各种请求的单个处理程序；</li><li>分发器：前端控制器可以使用将请求分派到相应的特定处理器的分派器对象；</li><li>视图：进行请求的对象；</li></ul></li></ul></li><li><h4 id="拦截过滤器模式"><a href="#拦截过滤器模式" class="headerlink" title="拦截过滤器模式"></a>拦截过滤器模式</h4><ul><li>过滤器：请求处理程序执行前或后执行某些任务的过滤器；</li><li>过滤器链：携带多个过滤器，并帮助在目标上以定义的顺序执行；</li><li>目标：请求处理程序；</li><li>过滤器管理器：管理过滤器和过滤器链；</li><li>客户端：向目标对象发送请求的对象；</li></ul></li><li><h4 id="服务定位模式"><a href="#服务定位模式" class="headerlink" title="服务定位模式"></a>服务定位模式</h4><ul><li>服务：将处理请求的实际服务，将在<code>JNDI</code>服务器中查找此类服务的引用；</li><li>上下文/初始上下文：<code>JNDI</code>上下文携带对用于查找目的的服务的引用；</li><li>服务定位器：通过<code>JNDI</code>查找缓存服务获得服务的单一联系点；</li><li>缓存：用于存储服务的引用以重用他们的缓存；</li><li>客户端：通过<code>ServiceLocator</code>调用服务的对象；</li></ul></li><li><h4 id="传输对象模式"><a href="#传输对象模式" class="headerlink" title="传输对象模式"></a>传输对象模式</h4><ul><li>业务对象：业务服务使用数据填充传输对象；</li><li>传输对象：具有仅设置/获取属性的方法的简单<code>POJO</code>；</li><li>客户端：请求或发送传输对象到业务对象；</li></ul></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的四大变量解析</title>
      <link href="/2019/10/02/java-zhong-de-si-da-bian-liang-jie-xi/"/>
      <url>/2019/10/02/java-zhong-de-si-da-bian-liang-jie-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="导读"><a href="#导读" class="headerlink" title="导读"></a>导读</h2><p>学习Java的过程中，一开始很容易被这些各种变量绕晕，这篇博客主要介绍了这几种变量之间的关系和区别。</p><h2 id="例程"><a href="#例程" class="headerlink" title="例程"></a>例程</h2><pre class="line-numbers language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>cunyu<span class="token punctuation">.</span>demo<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Demo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//成员变量、实例变量</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//成员变量、实例变量</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> ID<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//成员变量、实例变量</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String school <span class="token operator">=</span> <span class="token string">"卡塞尔学院"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//成员变量、静态变量(类变量)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String level <span class="token operator">=</span> <span class="token string">"SSS"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//成员变量、静态变量(类变量)</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setId</span><span class="token punctuation">(</span><span class="token keyword">int</span> ID<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>ID <span class="token operator">=</span> ID<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            String subject1 <span class="token operator">=</span> <span class="token string">"屠龙"</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//局部变量</span>            String subject2 <span class="token operator">=</span> <span class="token string">"炼金术"</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//局部变量</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"学习科目： "</span> <span class="token operator">+</span> subject1 <span class="token operator">+</span> <span class="token string">"、"</span> <span class="token operator">+</span> subject2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Demo demo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        demo<span class="token punctuation">.</span><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token number">23</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        demo<span class="token punctuation">.</span><span class="token function">setId</span><span class="token punctuation">(</span><span class="token number">14000001</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        demo<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"楚子航"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ID: "</span> <span class="token operator">+</span> demo<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"Age: "</span> <span class="token operator">+</span> demo<span class="token punctuation">.</span><span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"Name: "</span> <span class="token operator">+</span> demo<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"主修科目： "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        demo<span class="token punctuation">.</span><span class="token function">study</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"学院："</span> <span class="token operator">+</span> Demo<span class="token punctuation">.</span>school<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"等级："</span> <span class="token operator">+</span> Demo<span class="token punctuation">.</span>level<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="各变量联系与区别"><a href="#各变量联系与区别" class="headerlink" title="各变量联系与区别"></a>各变量联系与区别</h2><ul><li><p>成员变量：作用范围是整个类，相当于C中的全局变量，定义在方法体和语句块之外，一般定义在类的声明之下；成员变量包括实例变量和静态变量(类变量)；</p></li><li><p>实例变量：独立于与方法之外的变量，无static修饰，声明在一个类中，但在方法、构造方法和语句块之外，数值型变量默认值为0，布尔型默认值为false，引用类型默认值为null；</p></li><li><p>静态变量(类变量)：独立于方法之外的变量，用static修饰，默认值与实例变量相似，一个类中只有一份，属于对象共有，存储在静态存储区，经常被声明为常量，调用一般是类名.静态变量名，也可以用对象名.静态变量名调用；</p></li><li><p>局部变量：类的方法中的变量，访问修饰符不能用于局部变量，声明在方法、构造方法或语句块中，在栈上分配，无默认值，必须经初始化；</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用IDE代码开头模板</title>
      <link href="/2019/10/02/chang-yong-ide-dai-ma-kai-tou-mo-ban/"/>
      <url>/2019/10/02/chang-yong-ide-dai-ma-kai-tou-mo-ban/</url>
      
        <content type="html"><![CDATA[<h1 id="Pycharm"><a href="#Pycharm" class="headerlink" title="Pycharm"></a>Pycharm</h1><pre class="line-numbers language-python"><code class="language-python"><span class="token comment" spellcheck="true">#!/usr/bin/env python</span><span class="token comment" spellcheck="true"># -*- coding: utf-8 -*-</span><span class="token comment" spellcheck="true"># @version : 1.0</span><span class="token comment" spellcheck="true"># @Time    : ${DATE} ${TIME}</span><span class="token comment" spellcheck="true"># @Author  : cunyu</span><span class="token comment" spellcheck="true"># @Email   : cunyu1024@foxmail.com</span><span class="token comment" spellcheck="true"># @Site    : https://cunyu1943.github.io</span><span class="token comment" spellcheck="true"># @File    : ${NAME}.py</span><span class="token comment" spellcheck="true"># @Software: ${PRODUCT_NAME}</span><span class="token comment" spellcheck="true"># @Desc    :</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="IntelliJ-IDEA"><a href="#IntelliJ-IDEA" class="headerlink" title="IntelliJ IDEA"></a>IntelliJ IDEA</h1><pre class="line-numbers language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Created with IntelliJ IDEA. * Version : 1.0 * Author  : cunyu * Email   : cunyu1024@foxmail.com * Website : https://cunyu1943.github.io  * Date    : ${DATE} ${TIME} * Project : ${PROJECT_NAME} * Package : ${PACKAGE_NAME} * Class   : ${CLASS_NAME} * Desc    :  */</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h1><pre class="line-numbers language-c++"><code class="language-c++">/************************************************************************  * 项目名称 :  $rootnamespace$    * 类 名 称 :  $safeitemrootname$  * 版 本 号 :  1.0         * 作    者 :  cunyu * 邮    箱 :  cunyu1024@foxmail.com * 网    站 :  https://cunyu1943.github.io * 创建时间 :  $time$ * 项目描述 :      ************************************************************************/  <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h1><pre><code>set autoindent                  " 按下回车后，下一行缩进格式与上一行保持一直set tabstop=4                   " 设置Tab键显示的空格数set spell spelllang=en_us       "英语单词拼写检查set number                      " 设置行号set nocompatible                " 设置是否与Vi兼容syntax on                       " 语法高亮set showmode                    " 显示当前属于命令模式还是插入模式set encoding=utf-8              " 设置utf-8编码set t_Co=256                    " 启用256色filetype indent on              " 文件类型检查set noerrorbells                "出错时不要发出响声警告set mouse=a                     " 支持鼠标</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Pycharm </tag>
            
            <tag> IntelliJ IDEA </tag>
            
            <tag> Visual Studio </tag>
            
            <tag> Vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XMind使用入门教程</title>
      <link href="/2019/10/02/xmind-shi-yong-ru-men-jiao-cheng/"/>
      <url>/2019/10/02/xmind-shi-yong-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是思维导图"><a href="#什么是思维导图" class="headerlink" title="什么是思维导图"></a>什么是思维导图</h1><p>借用百度百科的介绍，思维导图又称脑图、心智导图。是一种将思维形象化的方法，它利用图文并重的方法，将各级主题之间的关系用相互隶属与相关的层级图表现出来，将主题关键词与图像、颜色等建立记忆连接，从而使人们能够充分利用左右脑的机能。总结来说，思维导图就是以层次感的方式展示我们想法的图像式思考辅助工具。</p><h1 id="思维导图的优点"><a href="#思维导图的优点" class="headerlink" title="思维导图的优点"></a>思维导图的优点</h1><p><img src="https://upload-images.jianshu.io/upload_images/9747350-13d35573dd8cdd72.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt></p><h1 id="XMind"><a href="#XMind" class="headerlink" title="XMind"></a>XMind</h1><p>XMind专业版是需要付费的，但是基础版的也可以使用，只是较之专业版的有的功能受限，但满足日常使用需求已经足以。<a href="https://www.xmind.cn/download/win/" target="_blank" rel="noopener">下载地址</a>；</p><p><img src="https://upload-images.jianshu.io/upload_images/9747350-50df2f974ae870db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt></p><h1 id="XMind快捷键"><a href="#XMind快捷键" class="headerlink" title="XMind快捷键"></a>XMind快捷键</h1><p><img src="https://upload-images.jianshu.io/upload_images/9747350-8ea91ba973cea05c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt></p><h1 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h1><ul><li><p>修改节点中的内容；<br><img src="https://upload-images.jianshu.io/upload_images/9747350-3dc9270f213d08db.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt></p></li><li><p>创建同级节点和子节点；<br><img src="https://upload-images.jianshu.io/upload_images/9747350-70765e0ac61bd614.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt></p></li><li><p>添加优先等级图标；<br><img src="https://upload-images.jianshu.io/upload_images/9747350-30dde6317ffa6417.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt></p></li><li><p>更改思维导图样式；<br><img src="https://upload-images.jianshu.io/upload_images/9747350-4094f2b476273c87.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt></p></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>XMind是一款十分有助于效率提高的工具，也很容易上手操作，绝对是学习生活中的一大利器。如果你对自己的学习工作效率不是十分满意，那么XMind绝对值得一试哦！！！<br>以下附上几张XMind官方给出的模版：</p><p><img src="https://upload-images.jianshu.io/upload_images/9747350-85a527c0aa1c3995.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/9747350-3973bf4ef2004041.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/9747350-5f8caf160bec24f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt></p><p><img src="https://upload-images.jianshu.io/upload_images/9747350-2313556507b99455.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/620" alt></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> XMind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql-8.0.13压缩版安装之Windows10篇</title>
      <link href="/2019/10/02/mysql-8-0-13-ya-suo-ban-an-zhuang-zhi-windows10-pian/"/>
      <url>/2019/10/02/mysql-8-0-13-ya-suo-ban-an-zhuang-zhi-windows10-pian/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>系统环境：Windows 10 1803版本；</li><li>压缩包：MySQL-8.0.13 Windows zip包<a href="https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-8.0.13-winx64.zip" target="_blank" rel="noopener">下载</a>；</li></ul><h2 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h2><h4 id="1-加载安装包到你的安装目录"><a href="#1-加载安装包到你的安装目录" class="headerlink" title="1. 加载安装包到你的安装目录"></a>1. 加载安装包到你的安装目录</h4><p>将下载的MySQL压缩包解压并移到你所要安装的路径，下面以我的安装路径<code>D:\Program Files\mysql-8.0.13-winx64</code>为例；</p><h4 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2.  配置文件"></a>2.  配置文件</h4><p>在上述目录下新建<code>my.ini</code>文件，然后在文件中加入以下配置：在上述目录下新建<code>my.ini</code>文件，然后在文件中加入以下配置：</p><pre class="line-numbers language-shell"><code class="language-shell">[mysqld]# 设置3306端口port=3306# 设置mysql的安装目录basedir=D:\Program Files\mysql-8.0.13-winx64# 设置mysql数据库的数据的存放目录datadir=D:\Program Files\mysql-8.0.13-winx64\data# 允许最大连接数max_connections=200# 允许连接失败的次数max_connect_errors=10# 服务端使用的字符集默认为utf8character-set-server=utf8#使用–skip-external-locking MySQL选项以避免外部锁定。该选项默认开启external-locking = FALSE# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB # 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysqld_safe]log-error=D:\Program Files\mysql-8.0.13-winx64\mysql_oldboy.errpid-file=D:\Program Files\mysql-8.0.13-winx64\mysqld.pid# 定义mysql应该支持的sql语法，数据校验sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306# 设置mysql客户端默认字符集default-character-set=utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3. 配置环境变量"></a>3. 配置环境变量</h4><ul><li><p>打开控制面板-&gt;系统与安全-&gt;系统，进入高级系统设置，如下图所示；<br><img src="http://upload-images.jianshu.io/upload_images/9747350-e5eb79a0ed36843b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p></li><li><p>然后进行环境变量的设置，如下图；</p></li></ul><p><img src="http://upload-images.jianshu.io/upload_images/9747350-7e1751a1f568266b?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="http://upload-images.jianshu.io/upload_images/9747350-c1cc60337028b17d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br><img src="http://upload-images.jianshu.io/upload_images/9747350-7225cdc7ee9ef783?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="4-初始化"><a href="#4-初始化" class="headerlink" title="4. 初始化"></a>4. 初始化</h4><p>控制台进入MySQL解压后的路径，然后以管理员身份执行如下命令；</p><pre class="line-numbers language-shell"><code class="language-shell">mysqld --initialize --console<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>注意</strong>：执行成功后会打印出初始的root用户密码，一定要记住！！！方便后边修改密码；<br><img src="http://upload-images.jianshu.io/upload_images/9747350-033f2e6de448ef2c?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="5-安装数据库服务"><a href="#5-安装数据库服务" class="headerlink" title="5. 安装数据库服务"></a>5. 安装数据库服务</h4><p>接上一步初始化数据库后，继续执行如下命令；</p><pre class="line-numbers language-shell"><code class="language-shell">mysqld --install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>因为博主已经安装过了，所以会提示服务已存在，若是第一次安装，则不会提示已安装；<br><img src="http://upload-images.jianshu.io/upload_images/9747350-6bfbcb57c014d944?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h4 id="6-启动与关闭MySQL数据库服务"><a href="#6-启动与关闭MySQL数据库服务" class="headerlink" title="6. 启动与关闭MySQL数据库服务"></a>6. 启动与关闭MySQL数据库服务</h4><pre class="line-numbers language-shell"><code class="language-shell"># 开启net start mysql# 关闭net stop mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-修改初始root用户密码"><a href="#7-修改初始root用户密码" class="headerlink" title="7. 修改初始root用户密码"></a>7. 修改初始root用户密码</h4><p>先用刚才记住的初始root用户密码登陆，然后进行密码更改，命令如下；</p><pre class="line-numbers language-shell"><code class="language-shell"># 登陆mysql -u root -p # 然后提示你输入密码，输入上边初始化时默认给的初始化密码，进行登陆# 密码修改alter user 'root'@'localhost' identified by '新密码';# 修改密码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="http://upload-images.jianshu.io/upload_images/9747350-b3fbdeddb8aa4329?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h5 id="8-创建普通用户并设置密码"><a href="#8-创建普通用户并设置密码" class="headerlink" title="8. 创建普通用户并设置密码"></a>8. 创建普通用户并设置密码</h5><p>登入root用户后，创建新的用户并指定密码密码如下；</p><pre class="line-numbers language-shell"><code class="language-shell">CREATE USER 'userName'@'localhost' IDENTIFIED BY 'password';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后退出root用户登陆，尝试用你所创建的新用户进行登陆，登陆成功的提示如下；<br><img src="http://upload-images.jianshu.io/upload_images/9747350-eca60838194ccc4e?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>好了，通过上面的流程，是不是知道了如何在Windows 10系统下安装最新的压缩包版MySQL-8.0.13呢，而且文中也对如何修改root用户的默认密码以及如何创建新用户给出了解决方案，是不是简单，那就亲自动手试试吧；</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不同情况下修改MySql的root用户密码对应的方法</title>
      <link href="/2019/10/02/bu-tong-qing-kuang-xia-xiu-gai-mysql-de-root-yong-hu-mi-ma-dui-ying-de-fang-fa/"/>
      <url>/2019/10/02/bu-tong-qing-kuang-xia-xiu-gai-mysql-de-root-yong-hu-mi-ma-dui-ying-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="在我们使用MySQL时，常常会因为不同的原因需要对root用户密码进行修改，这篇博客主要介绍了以下三种情况下修改root用户密码的方式。"><a href="#在我们使用MySQL时，常常会因为不同的原因需要对root用户密码进行修改，这篇博客主要介绍了以下三种情况下修改root用户密码的方式。" class="headerlink" title="在我们使用MySQL时，常常会因为不同的原因需要对root用户密码进行修改，这篇博客主要介绍了以下三种情况下修改root用户密码的方式。"></a>在我们使用MySQL时，常常会因为不同的原因需要对root用户密码进行修改，这篇博客主要介绍了以下三种情况下修改root用户密码的方式。</h2><h3 id="未设置root密码之前："><a href="#未设置root密码之前：" class="headerlink" title="未设置root密码之前："></a>未设置root密码之前：</h3><ul><li>SET PASSWORD命令的方式：<pre><code>mysql -u rootmysql&gt;SET PASSWORD FOR 'root'@'localhost' = PASSWORD('你要设置的密码');</code></pre></li><li>mysqladmin命令的方式：<pre><code>mysqladmin -u root password "你要设置的密码"</code></pre></li><li>UPDATE的方式直接编辑user表：<pre><code>mysql -u rootmysql&gt; USE mysql;mysql&gt; UPDATE user SET Password = PASSWORD('你要设置的密码') WHERE user = 'root';mysql&gt; FLUSH PRIVILEGES;</code></pre></li></ul><h3 id="设置过root之后："><a href="#设置过root之后：" class="headerlink" title="设置过root之后："></a>设置过root之后：</h3><ul><li>mysqladmin的方式：<pre><code>mysqladmin -u root password oldpass "你要设置的新密码"</code></pre></li></ul><h3 id="设置过root密码，但是忘记了："><a href="#设置过root密码，但是忘记了：" class="headerlink" title="设置过root密码，但是忘记了："></a>设置过root密码，但是忘记了：</h3><pre><code>mysqld_safe --skip-grant-tables&amp;mysql -u root mysqlmysql&gt; UPDATE user SET password = PASSWORD("你要设置的新密码") WHERE user = 'root' ;mysql&gt; FLUSH PRIVILEGES;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Socket在Server和Client间通信的工作原理</title>
      <link href="/2019/09/30/socket-zai-server-he-client-jian-tong-xin-de-gong-zuo-yuan-li/"/>
      <url>/2019/09/30/socket-zai-server-he-client-jian-tong-xin-de-gong-zuo-yuan-li/</url>
      
        <content type="html"><![CDATA[<h4 id="Socket之间的连接过程主要可以概括为以下三步："><a href="#Socket之间的连接过程主要可以概括为以下三步：" class="headerlink" title="Socket之间的连接过程主要可以概括为以下三步："></a>Socket之间的连接过程主要可以概括为以下三步：</h4><ol><li><p><strong>服务器建立监听</strong>：客户端初始化Socket动态库后创建套接字，然后指定客户端Socket的地址，循环绑定Socket直至成功，然后开始建立监听，此时客户端处于等待状态，实时监控网络状态；</p></li><li><p><strong>客户端提出请求</strong>：客户端的Socket向服务器端提出连接请求，此时客户端描述出它所要连接的Socket，指出要连接的Socket的相关属性，然后向服务器端Socket提出请求；</p></li><li><p><strong>连接确认并建立</strong>：当服务器端套接字监听到来自客户端的连接请求之后，立即响应请求并建立一个新进程，然后将服务器端的套接字的描述反馈给客户端，由客户端确认之后连接就建立成功，然后客户端和服务器两端之间可以相互通信，传输数据，此时服务器端的套接字继续等待监听来自其他客户端的请求；</p></li></ol><p><img src="http://upload-images.jianshu.io/upload_images/9747350-928b4a5b6d4526d4?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="server和client之间的基本工作原理流程图"></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 计算机知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言中的内存管理函数</title>
      <link href="/2019/09/30/c-yu-yan-zhong-de-nei-cun-guan-li-han-shu/"/>
      <url>/2019/09/30/c-yu-yan-zhong-de-nei-cun-guan-li-han-shu/</url>
      
        <content type="html"><![CDATA[<h3 id="malloc函数"><a href="#malloc函数" class="headerlink" title="malloc函数"></a>malloc函数</h3><ul><li>原型：extern void* malloc(unsigned int size)；</li><li>功能：动态分配内存；</li><li>注意：size仅仅为申请内存字节大小，与申请内存块中存储的数据类型无关，故编程时需要通过以下方式给出：”长度 * sizeof(数据类型)”；</li></ul><ul><li>示例：</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token comment" spellcheck="true">//动态分配内存，输入5个数据，并把低于60的值打印出来</span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> <span class="token operator">*</span>ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">*</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//分配内存</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token punctuation">{</span>            <span class="token function">scanf_s</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//输入数据</span>        <span class="token punctuation">}</span>    <span class="token keyword">int</span> min <span class="token operator">=</span> <span class="token number">60</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>min <span class="token operator">></span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%5d"</span><span class="token punctuation">,</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//打印出低于60的值</span>    <span class="token punctuation">}</span>    <span class="token function">free</span><span class="token punctuation">(</span>ptr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="free函数"><a href="#free函数" class="headerlink" title="free函数"></a>free函数</h3><ul><li>原型：void free(void * ptr)；</li><li>功能：搭配malloc()函数，释放malloc函数申请的动态内存；</li><li>注意：对于free(ptr)，若ptr为NULL，则可进行多次释放，若ptr是非空指针，则free对ptr只能进行一次操作，否则程序将崩溃；</li><li>示例：见malloc函数；</li><li>结果：见malloc函数；</li></ul><h3 id="realloc函数"><a href="#realloc函数" class="headerlink" title="realloc函数"></a>realloc函数</h3><ul><li><p>原型： void* realloc(void * ptr,unsigned int size)；</p></li><li><p>功能：先判断当前指针是否有足够的连续空间，若足够，扩大ptr指向的地址并返回，若不够，怎按size指定的大小分配空间，将原数据copy到新分配的内存中，然后释放原ptr所指向区域；</p></li><li><p>注意：内存使用完毕后，应使用free()函数释放，但原来的指针是自动释放，不需要使用free；</p></li><li><p>示例：</p></li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>   <span class="token keyword">char</span> <span class="token operator">*</span>str<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 一开始的内存分配 */</span>    str <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcpy</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"String = %s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 重新分配内存 */</span>    str <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">char</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">realloc</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">strcat</span><span class="token punctuation">(</span>str<span class="token punctuation">,</span> <span class="token string">", C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"String = %s\n"</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">free</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="calloc函数"><a href="#calloc函数" class="headerlink" title="calloc函数"></a>calloc函数</h3><ul><li>原型：void* calloc（unsigned int num，unsigned int size）；</li><li>功能：为已经分配的内存重新分配空间并复制内容；</li><li>注意：num：对象个数，size：对象占据的内存字节数，相较于malloc函数，calloc函数会自动将内存初始化为0；</li></ul><ul><li>示例：</li></ul><pre class="line-numbers language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">int</span> i<span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token operator">*</span>ptr<span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"元素个数为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>    ptr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">calloc</span><span class="token punctuation">(</span>num<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入 %d 个数字：\n"</span><span class="token punctuation">,</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"输入的数字为："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> num<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d "</span><span class="token punctuation">,</span> ptr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">system</span><span class="token punctuation">(</span><span class="token string">"pause"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>程序员常用编辑器推荐</title>
      <link href="/2019/09/30/cheng-xu-yuan-chang-yong-bian-ji-qi-tui-jian/"/>
      <url>/2019/09/30/cheng-xu-yuan-chang-yong-bian-ji-qi-tui-jian/</url>
      
        <content type="html"><![CDATA[<p>对于一个程序员而言，一款称手的代码编辑器是十分重要的。一款好的代码编辑器能够大大提高开发效率，节省开发时间。而且现在许多的代码编辑器功能十分强大，不仅仅只是编写代码、查看源文件，还可以查看txt文档，也支持Markdown格式的写作等等。下面就简要的介绍几款的代码编辑器，</p><h3 id="Vim"><a href="#Vim" class="headerlink" title="Vim"></a>Vim</h3><ul><li>官网下载地址：<a href="https://www.vim.org/" target="_blank" rel="noopener">https://www.vim.org/</a></li><li>Github下载地址：<a href="https://github.com/vim/vim/releases" target="_blank" rel="noopener">https://github.com/vim/vim/releases</a></li><li>使用教程：<a href="https://www.runoob.com/linux/linux-vim.html" target="_blank" rel="noopener">https://www.runoob.com/linux/linux-vim.html</a></li></ul><h3 id="EditPlus"><a href="#EditPlus" class="headerlink" title="EditPlus"></a>EditPlus</h3><ul><li>官网下载地址：<a href="https://www.editplus.com/" target="_blank" rel="noopener">https://www.editplus.com/</a></li><li>中文破解版：<a href="http://www.pc6.com/softview/SoftView_36775.html" target="_blank" rel="noopener">http://www.pc6.com/softview/SoftView_36775.html</a></li></ul><h3 id="UltraEdit"><a href="#UltraEdit" class="headerlink" title="UltraEdit"></a>UltraEdit</h3><ul><li>官网下载地址：<a href="https://www.ultraedit.com/" target="_blank" rel="noopener">https://www.ultraedit.com/</a></li><li>中文官网下载地址：<a href="http://www.ultraedit.cn/" target="_blank" rel="noopener">http://www.ultraedit.cn/</a></li></ul><h3 id="Sublime-Text"><a href="#Sublime-Text" class="headerlink" title="Sublime Text"></a>Sublime Text</h3><ul><li>官网下载地址：<a href="http://www.sublimetext.com/3" target="_blank" rel="noopener">http://www.sublimetext.com/3</a></li><li>中文版下载地址：<a href="http://sublimetextcn.com/" target="_blank" rel="noopener">http://sublimetextcn.com/</a></li><li>优点：功能强大、性能优良、界面美观、多平台兼容；</li><li>缺点：收费，不过收费也不是很贵，有条件的还是建议买个正版，省事又方便；</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLTY5MTdlYzk2MDgzMjI4YTMucG5n?x-oss-process=image/format,png" alt="图片来自百度"></p><h3 id="Notepad"><a href="#Notepad" class="headerlink" title="Notepad++"></a>Notepad++</h3><ul><li>官网下载地址：<a href="https://notepad-plus-plus.org/" target="_blank" rel="noopener">https://notepad-plus-plus.org/</a></li><li>优点：国人(台湾人侯金吾)开发，有完整的中文接口，并支持多国语言，免费开源，轻便；</li><li>缺点：目前只支持Windows平台；</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLWY4N2I5NDEyZGVjMTRhYjkucG5n?x-oss-process=image/format,png" alt="图片来自百度"></p><h3 id="Visual-Studio-Code"><a href="#Visual-Studio-Code" class="headerlink" title="Visual Studio Code"></a>Visual Studio Code</h3><ul><li>官网下载地址：<a href="https://code.visualstudio.com/" target="_blank" rel="noopener">https://code.visualstudio.com/</a></li><li>优点：作为宇宙最强IDE Visual Studio开发者微软旗下的一款产品，它的强大毋庸置疑，就不再赘述。而且最重要的一点，这款编辑器是完全开源免费的，也支持多平台；</li><li>缺点：相对来说，安装体积较大，比不上sublime、notepad等轻便；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLWY3MDFjOWNkOTgyY2JiYmYucG5n?x-oss-process=image/format,png" alt></li></ul><h3 id="Atom"><a href="#Atom" class="headerlink" title="Atom"></a>Atom</h3><ul><li>官网下载地址：<a href="https://atom.io/" target="_blank" rel="noopener">https://atom.io/</a></li><li>优点：用户界面简洁直观，简单易用，上手很快，由全球最大同性交友平台github推出，完全免费开源，支持多平台，PS：还有各种意想不到的酷炫功能，自己去探索吧；</li><li>缺点：由于集成了许多功能，安装的时候相对臃肿，轻便性有待提高；</li></ul><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLTkzN2ZhYmRmZDk4NWRhZDAucG5n?x-oss-process=image/format,png" alt="图片来自百度"></p><p>好了，以上就推荐了几款作为开发者最常用的几个代码编辑器。正所谓萝卜白菜，各有所爱，所以笔者也不能说哪一款是最好的。如果你更倾向于轻便，那Sublime Text和Notepad++或许是更好的选择。但如果你想要易上手之类的，Atom和VS Code也许会更适合你。当然了，Sublime Text和Notepad++也可以通过安装各种插件来使功能更加强大，这就需要你去折腾了。以上就是我的看法了，希望你看了这篇博客后能够选到最适合你的代码编辑器。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vim </tag>
            
            <tag> Visual Studio Code </tag>
            
            <tag> Sublime Text </tag>
            
            <tag> Notepad++ </tag>
            
            <tag> Atom </tag>
            
            <tag> UltraEdit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown写作入门</title>
      <link href="/2019/09/30/markdown-xie-zuo-ru-men/"/>
      <url>/2019/09/30/markdown-xie-zuo-ru-men/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是Markdown格式"><a href="#什么是Markdown格式" class="headerlink" title="什么是Markdown格式"></a>什么是Markdown格式</h3><p>Markdown格式是一种可用普通文本编辑器编写的标记语言，使用者能够通过简单的标记语法，对自己所写文本内容进行简单的格式排版；</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>语法简洁易学，且功能比纯文本强大；</li><li>格式转换方便，兼容性强，可读性极好；</li></ul><h3 id="写作格式"><a href="#写作格式" class="headerlink" title="写作格式"></a>写作格式</h3><h4 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h4><p>每多加一级则添加一个 # 号；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLTI0OGM5ODA2ZmIyNGU4OTAucG5n" alt></p><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><ul><li><p>有序列表<br>数字加上一个英文句点，空格后输入内容；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLTFkMzRjNWU5ODcwMDU2YjEucG5n" alt></p></li><li><p>无序列表<br>-、+、*为无序列表标识；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLWIzNmIxYWRjMzcxMTNmZWQucG5n" alt></p></li></ul><h4 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h4><p>两个连续 * 或者 _ 包含内容；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLTJiMDFmYTdjODFmMWM1YjMucG5n" alt></p><h4 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h4><p>一个 * 或者 _ 包含内容；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLTE5ZGI0ZjcwYTIwNGIyMTUucG5n" alt></p><h4 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h4><p>两个 ~~ 包含；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLTE3M2M4NGM5NjZjMTAzMzYucG5n" alt></p><h4 id="标记文本"><a href="#标记文本" class="headerlink" title="标记文本"></a>标记文本</h4><p>两个<code>==</code>包含，格式如下；<br><code>==demo==</code></p><h4 id="上下标"><a href="#上下标" class="headerlink" title="上下标"></a>上下标</h4><ul><li>上标<br><code>^</code>包含，格式如下；<br><code>demo^demo^</code></li><li>下标<br><code>~</code>包含，格式如下；<br><code>demo~demo~</code></li></ul><h4 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h4><p>三个及以上的 *、_、- 用于建立分割线；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLTcxM2M4ZDg3OWI0ODM5N2YucG5n" alt><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLWExYmY2MjRjYmQxOTU4YmIucG5n" alt><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLWU1N2U0YTI4ZmIxZjY1MWYucG5n" alt></p><h4 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h4><p>三个连续 ` 包含代码内容；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLWQ4YTY4MjUzMzQ5MWNlMmQucG5n" alt></p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>单个 &gt; 标记区块引用；<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLTZmMWYxYTBjNzM3ZTliOTMucG5n" alt></p><h4 id="链接和图片"><a href="#链接和图片" class="headerlink" title="链接和图片"></a>链接和图片</h4><ul><li><code>[显示的文本](链接地址)；</code><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLTFkNzM3YzUwMTAzNmQzYTIucG5n" alt></li><li><code>[外链图片转存失败(img-XrVu45Zv-1563331849244)(图片链接地址)]；</code><br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLWEzZWZjM2M2M2YxNTVkYzYucG5n" alt></li></ul><h4 id="上下角标"><a href="#上下角标" class="headerlink" title="上下角标"></a>上下角标</h4><h5 id="上角标"><a href="#上角标" class="headerlink" title="上角标"></a>上角标</h5><pre class="line-numbers language-text"><code class="language-text">1. <sup>内容</sup>2. ^<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h5 id="下角标"><a href="#下角标" class="headerlink" title="下角标"></a>下角标</h5><pre class="line-numbers language-text"><code class="language-text">1. <sub>内容</sub>2. _<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h4><ul><li><p>起始和结尾标志<br>数学公式以<code>$</code>开头和结尾，若公式要独占一行，则以<code>$$</code>开头和结尾；</p></li><li><p>符号上下标<br>上标：<code>^</code>，如$a^2$；<br>下标：<code>_</code>，如$a_2$；</p></li><li><p>分组<br>使用<code>{}</code>将具有相同等级的内容扩入其中，成组处理</p></li><li><p>括号</p><ul><li>小括号：<code>()</code>；</li><li>中括号：<code>[]</code>；</li><li>尖括号：<code>\langle，\rangle</code>；</li><li>大括号：使用<code>\left</code>或<code>\right</code>让符号大小与邻近的公式相适应，如<code>(\frac{x}{y})和\left(\frac{x}{y}\right)</code>的区别<br>$$(\frac{x}{y})$$<br>$$\left(\frac{x}{y}\right)$$</li></ul></li><li><p>求和、极限和积分</p><ul><li>求和：<code>\sum</code>；</li><li>极限：<code>\lim</code>；</li><li>积分：<code>\int</code>；</li></ul></li><li><p>分式与根式</p><ul><li>分式：<code>\frac{分子}{分母}</code>；</li><li>根式：<code>\sqrt{根次}{底数}</code>；</li></ul></li></ul><h3 id="编辑器推荐"><a href="#编辑器推荐" class="headerlink" title="编辑器推荐"></a>编辑器推荐</h3><ul><li><p>Typora<br>一款所见即所得的Markdown编辑器，支持跨平台，下载地址：<a href="https://www.typora.io/" target="_blank" rel="noopener">https://www.typora.io/</a>;</p></li><li><p>GitNote<br>一款基于git的支持Markdown格式的笔记应用，虽然界面比较简陋，但是支持直接链接到自己的github同步，还解决了Typora中上传到网上的图床问题，下载地址：<a href="https://www.gitnoteapp.com/；" target="_blank" rel="noopener">https://www.gitnoteapp.com/；</a></p></li><li><p>VScode<br>微软出品的VScode可谓功能齐全，当然也是可以用来写作Markdown格式的，关于介绍及下载见我的另一篇文章<a href="https://www.jianshu.com/p/94f312103f9d" target="_blank" rel="noopener">开发者编辑器推荐</a>;</p></li><li><p>Cmd Markdown<br>这是由作业部落出品的一款Markdown写作软件，既有网页版，也有离线版，最大的特点在于联网时可以实时保存到云，不用担心因为各种原因导致的数据丢失问题，具体见<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">Cmd Markdown介绍</a>，<a href="https://www.zybuluo.com/mdeditor" target="_blank" rel="noopener">下载地址</a>;<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91cGxvYWQtaW1hZ2VzLmppYW5zaHUuaW8vdXBsb2FkX2ltYWdlcy85NzQ3MzUwLTc2NDExZGQ3ZDM5ODQ5OGEucG5n" alt></p></li></ul><h3 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h3><p>以上就是Markdown写作格式中最常用的语法，对于日常使用已经完全足够，至于更加高级的技巧，也可以在评论区贴出，大家一起交流学习！！！</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过Xshell远程连接Ubuntu</title>
      <link href="/2019/09/30/tong-guo-xshell-lian-jie-ubuntu/"/>
      <url>/2019/09/30/tong-guo-xshell-lian-jie-ubuntu/</url>
      
        <content type="html"><![CDATA[<p>一般情况下，安装好的Ubuntu系统中默认是只安装了<code>openssh-client</code>，此时只能通过此系统连接访问其他系统，但不具有让其他系统访问的权限。在终端查看ssh进程，输入<code>ps -e|grep ssh</code>，如果有安装<code>openssh-client</code>只会出现<code>ssh -agent</code>，不会出现<code>sshd</code>(因为博主已经安装<code>openssh-server</code>，所以会出现<code>sshd</code>)。</p><p><img src="https://img-blog.csdn.net/20180801141631186?watermark/2/text/5p2R6ZuoMTk0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/35" alt><br>此时要想开放本机SSH服务以便其他系统登陆访问，就必须安装<code>openssh-server</code>，安装过程如下：</p><ul><li>在终端中输入<code>sudo apt-get install openssh-server</code>，然后输入自己的<code>root</code>密码就可以了(因为博主已经安装过，所以提示的是升级)；</li></ul><p><img src="https://img-blog.csdn.net/20180801142429103?watermark/2/text/5p2R6ZuoMTk0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/35" alt></p><ul><li>然后启动<code>ssh-server</code>服务即可，开启方式，当然这两种开启方式都是需要切换到<code>root</code>用户或者提供密码权限的；</li></ul><ol><li><p><code>service ssh start</code></p></li><li><p><code>/etc/init.d/ssh start</code></p></li></ol><p><img src="https://img-blog.csdn.net/20180801143049189?watermark/2/text/5p2R6ZuoMTk0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/35" alt></p><ul><li>验证是否开启成功；</li></ul><p><img src="https://img-blog.csdn.net/20180801143318643?watermark/2/text/5p2R6ZuoMTk0Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/35" alt></p><ul><li>若再次查看<code>ssh</code>进程时，同时出现<code>sshd</code>、<code>ssh -agent</code>进程，则说明<code>openssh -service</code>已经安装成功；</li></ul><p><img src="https://img-blog.csdn.net/20180801143739776?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zOTY1NTAyOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/35" alt></p><ul><li>此时便可通过XShell访问Ubuntu了，依次填入主机IP、用户名已经用户密码便可成功连接到Ubuntu；</li></ul><p><img src="https://img-blog.csdn.net/20180801144354326?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zOTY1NTAyOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/35" alt></p><p><img src="https://img-blog.csdn.net/2018080114453685?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zOTY1NTAyOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt></p><p><img src="https://img-blog.csdn.net/20180801143846201?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zOTY1NTAyOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/35" alt></p><p><img src="https://img-blog.csdn.net/20180801144107643?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dpdGh1Yl8zOTY1NTAyOQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/35" alt></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Xshell </tag>
            
            <tag> Ubuntu </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git使用学习笔记</title>
      <link href="/2019/09/30/git-shi-yong-xue-xi-bi-ji/"/>
      <url>/2019/09/30/git-shi-yong-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><ul><li><p>定义<br>  Git，最先进的分布式版本控制系统之一，最初是由Linux之父Linus为了更好管理开源Linux系统而开发的一个软件；</p></li><li><p>下载：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a></p></li><li><p>安装</p><ul><li>Linux：<code>sudo apt-get install git</code></li><li>Windows、macOS通过官网下载安装包后进行安装即可；</li></ul></li><li><p>设置</p><p>  安装完成后，需要进行以下设置：</p><pre><code>$ git config --global user.name "user name"$ git config --global user.email "example@email.com"# 可选，让Git命令行显示颜色$ git config --global color.ui true</code></pre></li></ul><hr><h1 id="版本库创建及管理"><a href="#版本库创建及管理" class="headerlink" title="版本库创建及管理"></a>版本库创建及管理</h1><ul><li>如何创建版本库</li></ul><ol><li>先创建一个空文件夹，Windows下不再介绍，Linux以及macOS下可通过<code>$ mkdir gitlearn</code>命令创建；</li><li>通过<code>$ git init</code>将刚才创建的目录变为可管理的仓库;</li></ol><p><img src="https://i.loli.net/2019/09/20/PjMfbN1OR3mK7r5.png" alt></p><ul><li>如何将文件添加到版本库</li></ul><ol><li>在刚才创建的空文件夹中，添加你自己的文件，以readme.md为例；</li><li>用<code>git add</code>命令将文件添加到仓库；</li></ol><pre><code>$ git add readme.md</code></pre><ol start="3"><li>用<code>git commit</code>将文件提交到仓库；</li></ol><pre><code>$ git commit -m "this is a readme.md file."</code></pre><ul><li>如何查看仓库修改的内容</li></ul><ol><li><p>用<code>git status</code>查看仓库当前状态；</p></li><li><p>用<code>git diff filename</code>查看文件具体修改的内容；</p></li></ol><pre><code>$ git diff readme.txt</code></pre><ol start="3"><li><code>git log</code>查看最近到最远的提交日志</li></ol><pre><code>$ git log --pretty=oneline</code></pre><ol start="4"><li>回退之前的版本，先用<code>git log</code>查看提交历史，以确定commit_id，回退后，当想要重返未来版本时，用<code>git reflog</code>查看命令历史，从而确定重返版本commit_id，<code>HEAD</code>指向当前版本，为了在版本的历史之间穿梭，使用命令<code>git resrt --hard commit_id</code></li></ol><pre><code>$ git reset --hard HEAD^</code></pre><ol start="5"><li>直接丢弃工作区的某文件修改内容时，使用命令<code>git checkout -- filename</code></li></ol><pre><code>$ git checkout -- readme.md</code></pre><ol start="6"><li>删除文件，先在工作区将文件删除后，然后使用命令<code>git rm</code>将版本库中文件删除，然后通过<code>git commit</code>提交</li></ol><pre><code>$ git rm readme.md$ git commit -m "delete readme.md"</code></pre><hr><h1 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h1><ul><li><p>为了将本地Git和远程Github相连接，可以进行如下操作：</p><ul><li><p>确定<code>.ssh</code>目录下是否存在文件<code>id_rsa</code>和<code>id_rsa.pub</code>，有则复制<code>id_rsa.pub</code>中内容明将其添加到Github中的SSH Key，建立两者联系，可以在本地管理，</p></li><li><p>不存在则通过如下命令生成；</p><pre><code>$ ssh-keygen -t rsa -C "example@email.com"</code></pre></li></ul></li><li><p>如何添加远程仓库</p><ul><li><p>在本地通过如下命令建立本地仓库与远程仓库进行管理，然后就可以将本地仓库内容推送到Github仓库；</p><pre><code>$ git remote add origin git@github.com:cunyu1943/gitlearn.git</code></pre></li><li><p>从远程仓库克隆岛本地：</p><pre><code>$ git clone https://github.com/cunyu1943/the_journey_to_nlp.git</code></pre></li></ul></li><li><p>将本地仓库内容推送到远程仓库；</p></li></ul><pre><code># 第一次推送$ git push -u origin master# 之后的推送$ git push origin master</code></pre><hr><h1 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h1><ul><li>创建并切换分支</li></ul><pre><code>$ git switch -c dev# 等价命令$ git checkout -b dev# 等价命令$ git branch dev$ git checkout dev</code></pre><ul><li>查看当前分支，前边标有$*$代表当前分支，切换回$master$分支；</li></ul><pre><code>$ git branch$ git checkout/switch master</code></pre><ul><li>将$dev$分支合并到$master$分支；</li></ul><pre><code>$ git merge dev</code></pre><ul><li>删除分支；</li></ul><pre><code>$ git branch -d dev</code></pre><ul><li>强制删除未合并分支；</li></ul><pre><code>$ git branch -D dev</code></pre><ul><li>查看分支合并图</li></ul><pre><code>$ git log --graph</code></pre><hr><h1 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h1><ul><li><p>查看远程库信息：<code>git remote -v</code>；</p></li><li><p>本地新建分支若不推送到远程，则对其他人不可见；</p></li><li><p>本地推送到远程库，<code>git push origin branch-name</code>，若推送失败，则用<code>git pull</code>抓取远程新提交；</p></li></ul><pre><code>$ git push origin master# 若推送失败，则先执行如下命令$ git pull</code></pre><ul><li>本地创建和远程分支对应分支，<code>git checkout -b branch-name origin/branch-name</code></li></ul><pre><code>$ git checkout -b dev origin/dev</code></pre><ul><li>建立本地分支和远程分支的关联，<code>git branch --set-upstream branch-name origin/branch-name</code></li></ul><pre><code>$ git branch --set-upstream dev origin/dev</code></pre><ul><li>从远程抓取分支则使用<code>git pull</code>，若有冲突，则先解决处理后再处理；</li></ul><hr><h1 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h1><ul><li><p>先切换到需要打标签的分支<code>git switch branch-name</code>；</p></li><li><p>打标签并查看；</p></li></ul><pre><code># 打一个名为"v1.0"的标签$ git tag v1.0# 查看所有标签$ git tag</code></pre><ul><li>查看标签信息，<code>git show &lt;tagname&gt;</code>；</li></ul><pre><code>$ git show v1.0</code></pre><ul><li>创建带有说明的标签，用<code>-a</code>打标签名，<code>-m</code>指定说明文字；</li></ul><pre><code>$ git tag -a v1.0 -m "version 1.0 released" 132gsfh</code></pre><ul><li>删除标签，本地使用<code>git tag -d &lt;tagname&gt;</code>，远程则使用<code>git push origin :refs/tags/&lt;tagname&gt;</code></li></ul><pre><code># 删除本地标签$ git tag -d v30.0# 删除远程标签$ git push origin :refs/tags/v30.0</code></pre><ul><li>将标签推送到远程<code>git push origin &lt;tagname&gt;</code></li></ul><pre><code># 推送某一标签$ git push origin v1.0# 推送所有标签$ git push origin --tags</code></pre><hr><h1 id="建立Github和Gitee共同远程连接"><a href="#建立Github和Gitee共同远程连接" class="headerlink" title="建立Github和Gitee共同远程连接"></a>建立Github和Gitee共同远程连接</h1><ul><li>删除某一关联的远程库，<code>git remote rm &lt;basename&gt;</code></li></ul><pre><code>$ git remote rm origin</code></pre><ul><li>关联Gitee远程库，<code>git remote add &lt;basename&gt; git@gitee.com:&lt;username&gt;/&lt;basename&gt;.git</code></li></ul><pre><code>$ git remote add gitee git@gitee.com:cunyu1943/notes.git</code></pre><ul><li>关联Github远程库，<code>git remote add &lt;basename&gt; git@github.com:&lt;username&gt;/&lt;basename&gt;.git</code></li></ul><pre><code>$ git remote add github git@github.com:cunyu1943/notes.git</code></pre><p>-推送到Gitee和Github</p><pre><code># 推送到Gitee$ git push gitee master# 推送到Github$ git push github master</code></pre><hr><h1 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h1><ul><li><p>忽略特殊文件</p><p>  此时需要编写<code>.gitignore</code>文件，文件要放到版本库中，且可以对<code>.gitignore</code>进行版本管理；</p></li><li><p>配置命令别名</p></li></ul><pre><code># 举例$ git config --global alias st status$ git config --global alias checkout co$ git config --global alias commit cm</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github使用中遇到的问题集锦</title>
      <link href="/2019/09/30/github-shi-yong-zhong-yu-dao-de-wen-ti-ji-jin/"/>
      <url>/2019/09/30/github-shi-yong-zhong-yu-dao-de-wen-ti-ji-jin/</url>
      
        <content type="html"><![CDATA[<h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><p>对于我们国内用户，有时候浏览器在进入github网站时，会出现无法加载或加载很慢的问题，针对这一问题，很是头疼，为解决这一问题，在网上搜索到的解决方法如下；</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><ul><li>修改hosts文件，在hosts文件中加入以下内容：</li></ul><pre><code># GitHub Start# 针对无法加载或加载慢的问题192.30.253.112 github.com192.30.253.119 gist.github.com151.101.100.133 assets-cdn.github.com151.101.100.133 raw.githubusercontent.com151.101.100.133 gist.githubusercontent.com151.101.100.133 cloud.githubusercontent.com151.101.100.133 camo.githubusercontent.com151.101.100.133 avatars0.githubusercontent.com151.101.100.133 avatars1.githubusercontent.com151.101.100.133 avatars2.githubusercontent.com151.101.100.133 avatars3.githubusercontent.com151.101.100.133 avatars4.githubusercontent.com151.101.100.133 avatars5.githubusercontent.com151.101.100.133 avatars6.githubusercontent.com151.101.100.133 avatars7.githubusercontent.com151.101.100.133 avatars8.githubusercontent.com# 下载慢问题219.76.4.4 github-cloud.s3.amazonaws.com# GitHub End</code></pre><ul><li><p>hosts文件所在目录</p><ul><li>Windows：<code>C:\Windows\System32\drivers\etc\hosts</code></li><li>Linux：<code>\etc\hosts</code></li></ul></li><li><p>修改后生效方法</p><ul><li>关机重启</li><li>断网重连</li><li>Window：Win+R，输入cmd回车，然后在cmd窗口中输入：<code>ipconfig /flushdns</code></li><li>Linux：Ctrl+Alt+T打开终端，输入<code>sudo rcnscd restart</code></li></ul></li></ul><hr><h1 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h1><p>使用git同时同步github以及gitee；</p><h1 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h1><p>修改版本库<code>.git/config</code>文件，在文件中加入github和gitee中对应版本库的url，如下例，将我github和gitee中PTA版本库url同时加入，然后在使用git就可以同时同步两端；</p><pre><code>[core]    repositoryformatversion = 0    filemode = false    bare = false    logallrefupdates = true    symlinks = false    ignorecase = true[remote "origin"]    url = https://gitee.com/cunyu1943/PTA.git    url = https://github.com/cunyu1943/PTA.git    fetch = +refs/heads/*:refs/remotes/origin/*[branch "master"]    remote = origin    merge = refs/heads/master</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
